=head1 The Default constructor

The Default constructor will accept any named parameters defined by 'construct_with'. In the absence of a 'construct_with'
declaration, any parameters passed to the default constructor are ignored.

The example counter in the L<Class::Minion/SYNOPSIS> always starts at zero. Let's upgrade it to start from a user supplied value.

    package Example::Construction::Counter;

    use Class::Minion
        interface => [ qw( next ) ],

        construct_with => {
            start => {
                assert => {
                    is_integer => sub { $_[0] =~ /^\d+$/ }
                },
            },
        },
        implementation => 'Example::Construction::Acme::Counter';

    1;

    package Example::Construction::Acme::Counter;

    use strict;

    our %__Meta = (
        has  => {
            count => { init_arg => 'start' },
        }, 
    );

    sub next {
        my ($self) = @_;

        $self->{$$}{count}++;
    }

    1;

Now we can test it

    use Test::Most tests => 5;
    use Example::Construction::Counter;

    my $counter = Example::Construction::Counter->new(start => 10);

    is $counter->next => 10;
    is $counter->next => 11;
    is $counter->next => 12;

    throws_ok { Example::Construction::Counter->new } qr/Param 'start' was not provided/;
    throws_ok { Example::Construction::Counter->new(start => 'abc') } 
            qr/Parameter 'start' failed check 'is_integer'/;

Here the 'count' attribute is bound to the 'start' constructor parameter using the init_arg declaration. We also used an assert declaration
to constrain the value of the 'start' parameter.

=head2 Positional parameters

Sometimes, we'd like our constructor to take positional parameters. Consider a set object that we'd create by passing a list of items.

This can be acheieved using the "build_args" declaration, with which we use a sub to wrap the argument array in a hash:

    package Example::Construction::Set_v1;

    use Class::Minion

        interface => [qw( add has )],
        construct_with => { items => {} },

        build_args => sub {
            my ($class, @items) = @_;

            return { items => \@items };
        },

        implementation => 'Example::Construction::Acme::Set_v1',
    ;

    1;

In the implementation, we convert the argument array to a hash

    package Example::Construction::Acme::Set_v1;

    use strict;

    our %__Meta = (
        has => { 
            set => { 
                default => sub { {} },
                init_arg => 'items',
                map_init_arg => sub { return { map { $_ => 1 } @{ $_[0] } } },
            } 
        },
    );

    sub has {
        my ($self, $e) = @_;
        exists $self->{$$}{set}{$e};
    }

    sub add {
        my ($self, $e) = @_;
        ++$self->{$$}{set}{$e};
    }

    1;

And to test this

    use Test::More tests => 3;
    use Example::Construction::Set_v1;

    my $set = Example::Construction::Set_v1->new(1 .. 4);

    ok $set->has(1);
    ok ! $set->has(5);
    $set->add(5);
    ok $set->has(5);
